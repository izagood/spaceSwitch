# spaceSwitch

# 요건
## 12명의 자리를 배치

1. 랜덤으로 자리를 배치함  
1. 앉지 않았던 분단을 우선으로 배치  
ex) 최초 자리배치 후 A가 1분단 1열에 배치되었다면 그다음 자리배치할때는 2,3분단이 우선이 되도록 랜덤 자리 배치  

1. 앉았던 자리에는 배치가 안되도록  
그러면 총 12번까지는 자리를 배치할수 있겠죠?  
1. 마지막으로 화면 효과추가    
자리배치 후 화면에 텍스트를 바로 뿌릴 수 도있고, 클릭한 자리만 보여줄수도 있고,  
투명했다가 불투명 등 에니메니션 효과를 줄수도 있고 라이브러리를 사용한다면, 복권 긁기 처럼 마우스로 긁는 부분만 글자가 보일수도 있어요

## 중요 논리
전제 - 앞 순서에서 자리를 고르면 내부 히스토리가 쌓이고
앞 순서의 내부 히스토리가 쌓인 상태에서 이전 그룹이 아닌 동시에
외부 히스토리와 내부 히스토리를 비교하여 할당 가능한 곳에 넣어준다.

여기의 알고리즘 순서   
1. 일단 이전 그룹이외의 그룹에 들어간다.
2. 내부 & 외부 히스토리에서 동시에 가능한 곳으로 간다.
3. 마지막 순서에는 들어갈 곳이 1곳 밖에 남지 않아서 자동으로 들어간다.


count1 이 12번째에는 외부 히스토리를 보면 들어갈 수 있는 곳이 다들 1곳 밖에없음
그래서 횟수를 카운트 해줌.
일반적으로 사용할 수 있으려면 맴버의 수 만큼 카운트하게 해야함.


-------
알고리즘 개선
- 현재 에러가 발생하는 이유
현재 그룹을 배제했기 때문

1. inOutOtherGroup 함수로 돌린다.
2. inOutOtherGroup == [[],[],[]] 인데 innerHistoryCheck(innerHistory, false) != false가 나와
false가 나온다는 이유는 모두 false가 아니라는 소리임
3. A가 들어갈 수 있는 자리에 들어가고(outGroup) 그 자리에 배정되었던
B를 inOutGroup을 먼저 실행해보고 들어갈 수 없으면
outGroup으로 배정한다.
while(!innerHistoryCheck(innerHistory, false)){
    C를 inOutGroup을 먼저 실행해보고 들어갈 수 없으면
    outGroup으로 배정한다.
}

결과적으로는 innerHistory에 true로 되어있는 곳에 할당이 될 때까지 while을 돌꺼임

아마 true가 1,2 개 정도? 일듯함